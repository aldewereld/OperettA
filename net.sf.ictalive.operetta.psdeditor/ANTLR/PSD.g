grammar PSD;
/*
 * NOTES: 
 * - This file has been created with ANTLRWorks v1.4 (which uses ANTLR 3.2)
 *
 * - When generating code with ANTLRWorks, make sure that Preferences / General / Output Path is set to:
  ../src/net/sf/ictalive/operetta/psdeditor/antlr/
 *
 * - After generating, refresh project root in Eclipse workspace (the .g file needs to be refreshed to have Eclipse SVN see it's dirty).
 *
 */
options {
	backtrack = true;
}

@rulecatch { } // disable automatic catching of errors by ANTLR

@lexer::header {
/*
 * Generated by ANTLR from net.sf.ictalive.operetta.psdeditor/ANTLR/PSD.g
 *
 * Do not modify this file directly.
 *
 */

package net.sf.ictalive.operetta.psdeditor.antlr;
}

@lexer::members {
    @Override
    public void reportError(RecognitionException e) {
        throw new IllegalArgumentException(e);
    }
}

@header {
/*
 * Generated by ANTLR from net.sf.ictalive.operetta.psdeditor/ANTLR/PSD.g
 *
 * Do not modify this file directly.
 *
 */

package net.sf.ictalive.operetta.psdeditor.antlr;
import java.util.Collections;
import org.antlr.runtime.Token;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import net.sf.ictalive.operetta.OM.PartialStateDescription;
import net.sf.ictalive.operetta.OM.PathFormula;
import net.sf.ictalive.operetta.OM.StateFormula;
import net.sf.ictalive.operetta.OM.Atom;
import net.sf.ictalive.operetta.OM.Term;
import net.sf.ictalive.operetta.OM.OM;
}

@members {
protected TransactionalEditingDomain editingDomain;
protected OM om;

public class ParseResult {
	public PartialStateDescription psd;
	public Ranges ranges;
	public ParseResult(PartialStateDescription psd, Ranges ranges) {
		this.psd = psd;
		this.ranges = ranges;
	}
}
    
public static ParseResult parse(TransactionalEditingDomain editingDomain, OM om, String inputStr) throws ParseException {
	//System.out.println("Input: \""+inputStr+"\"\n");
	PSDLexer lexer = new PSDLexer(new ANTLRStringStream(inputStr));
	CommonTokenStream tokens = new CommonTokenStream(lexer);
	PSDParser parser = new PSDParser(tokens);
	parser.editingDomain = editingDomain;
	
	parser.allRanges = parser.new Ranges();
	parser.om = om;

	try {
		PartialStateDescription psd = parser.root();
		parser.allRanges.patch(inputStr.length());
		return parser.new ParseResult(psd, parser.allRanges);
	}
	catch (IllegalArgumentException e) {
		RecognitionException lexerException = (RecognitionException)e.getCause();
		throw new ParseException(lexer.getErrorMessage(lexerException,lexer.getTokenNames()), lexerException.charPositionInLine);
	}
	catch (RecognitionException e)  {
		throw new ParseException(parser.getErrorMessage(e,parser.getTokenNames()), e.charPositionInLine);
	}
}

@Override
protected Object recoverFromMismatchedToken(IntStream input,
    	int ttype,
    	BitSet follow)
throws RecognitionException
{
	throw new MismatchedTokenException(ttype, input);
}
    
// return the position of the token 
int getPos(Token start) {
	return start.getCharPositionInLine();
}

// return the position of the next token to be processed
int getCurrentPos() {
	return input.LT(1).getCharPositionInLine();
}

public Ranges allRanges;

public class Ranges extends ArrayList<Range>{
	public Ranges() {
	}
	
	public Ranges(Token start) {
		super();
	}

	// track is called on creation, but also in each of the chain rules, even if the chain has only 1 element
	public void track(int startPos, int endPos, Object object) {
		//System.out.println("Tracking "+psd+": <"+startPos+","+endPos+">");
		add(new Range(object, startPos, endPos));
	}
	// reverse the list, so root range is at the top, and convert -1 to end position
	public void patch(int endPos) {
		Collections.reverse(this);
		for (Range range : this)
			if (range.endPos == -1)
				range.endPos = endPos;

	}
};

public class Range {
	public Object object;
	public int startPos;
	public int endPos;
	
	public Range(Object object, int startPos, int endPos) {
		this.object = object;
		this.startPos = startPos;
		this.endPos = endPos;
	}
}

}





root 	returns [PartialStateDescription sem]
	:
		state EOF { $sem = $state.sem; }
	|
		path EOF { $sem = $path.sem; }
	;

path 	returns [PathFormula sem] @init { Ranges psds = new Ranges($start); }
 	: 	p1=path1 { psds.track(getPos($start), getCurrentPos(), $p1.sem); } (('U') p2=path1 {  psds.track(getPos($start), getCurrentPos(), $p2.sem); })* {$sem = PSDSemantics.semPath( editingDomain, om, allRanges, psds); } 
	;
	
	// TODO: same precedence okay?
path1	returns [PathFormula sem]
 	:	'X'  state { $sem = PSDSemantics.semPath1_0( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $state.sem ); }
 	|	'F'  state { $sem = PSDSemantics.semPath1_1( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $state.sem ); }
 	|	'G'  state { $sem = PSDSemantics.semPath1_2( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $state.sem ); }
	|	path2 { $sem = $path2.sem; }
	;
	
path2	returns [PathFormula sem] @init { Ranges psds = new Ranges($start); }
 	: 	 p1=path3 { psds.track(getPos($start), getCurrentPos(), $p1.sem); } (('->'|'\u2192') p2=path3 {  psds.track(getPos($start), getCurrentPos(), $p2.sem); })* {$sem = PSDSemantics.semPath2( editingDomain, om, allRanges, psds); } 
	;                                                                       // the non unicode is here for testing, but the psd editor only calls the parser with unicode operators

path3	returns [PathFormula sem] @init { Ranges psds = new Ranges($start); }
 	: 	p1=path4 { psds.track(getPos($start), getCurrentPos(), $p1.sem); } (('|'|'\u2228') p2=path4 {  psds.track(getPos($start), getCurrentPos(), $p2.sem); })* {$sem = PSDSemantics.semPath3( editingDomain, om, allRanges, psds); } 
	;

path4	returns [PathFormula sem] @init { Ranges psds = new Ranges($start); }
	: 	p1=path5 { psds.track(getPos($start), getCurrentPos(), $p1.sem); } (('^'|'&'|'\u2227') p2=path5 {  psds.track(getPos($start), getCurrentPos(), $p2.sem); })* {$sem = PSDSemantics.semPath4( editingDomain, om, allRanges, psds); } 
	;

path5	returns [PathFormula sem]
 	:	('~'|'\u00ac') p=path5 { $sem = PSDSemantics.semPath5( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $p.sem ); }
	|	'[' state ']' { $sem = $state.sem; }
	|	'(' path ')' { $sem = $path.sem; }		
	;
	
	
state 	returns [StateFormula sem, int endPos]
	: 	'E' path1 { $sem = PSDSemantics.semState0_0( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $path1.sem ); }
	|	'A' path1 { $sem = PSDSemantics.semState0_1( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $path1.sem ); }
	| 	state1 { $sem = $state1.sem; }
	;

state1	returns [StateFormula sem, int endPos] @init { Ranges psds = new Ranges($start); }
	: 	s1=state2 { psds.track(getPos($start), getCurrentPos(), $s1.sem); } (('->'|'\u2192') s2=state2 {  psds.track(getPos($start), getCurrentPos(), $s2.sem); })* {$sem = PSDSemantics.semState1( editingDomain, om, allRanges, psds); } 
	;

state2	returns [StateFormula sem, int endPos] @init { Ranges psds = new Ranges($start); }
	: 	s1=state3 { psds.track(getPos($start), getCurrentPos(), $s1.sem); } (('|'|'\u2228') s2=state3 {  psds.track(getPos($start), getCurrentPos(), $s2.sem); })* {$sem = PSDSemantics.semState2( editingDomain, om, allRanges, psds); } 
	;

state3	returns [StateFormula sem, int endPos] @init { Ranges psds = new Ranges($start); }
	: 	s1=state4 { psds.track(getPos($start), getCurrentPos(), $s1.sem); } (('^'|'&'|'\u2227') s2=state4 {  psds.track(getPos($start), getCurrentPos(), $s2.sem); })* {$sem = PSDSemantics.semState3( editingDomain, om, allRanges, psds); } 
	;

state4 	returns [StateFormula sem, int endPos]
	:	('~'|'\u00ac') s=state4 { $sem = PSDSemantics.semState4( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $s.sem ); }
	|	'(' state ')' { $sem = $state.sem; }
	|	predicate ('(' terms? ')')? { $sem = PSDSemantics.semAtom( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $predicate.text, $terms.sem ); } 
	;
		
// one or more terms, separated by ','
terms 	returns [ List<Term> sem] @init { List<Term> ts = new ArrayList<Term>(); }
	:	t1=term { ts.add($t1.sem); } (',' t2=term{ ts.add($t2.sem); } )* { $sem = ts; }
	;

term 	returns [Term sem]
	: function '(' terms? ')' { $sem = PSDSemantics.semTerm_0( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $function.text, $terms.sem); } 
     	| variable { $sem = PSDSemantics.semTerm_1( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $variable.text); }
     	| constant { $sem = PSDSemantics.semTerm_2( editingDomain, om, allRanges, getPos($start), getCurrentPos(), $constant.text); }
    	 ;			


variable returns [ String text ]
		: '$' IDENT { $text = $IDENT.text; };

predicate	: IDENT | OPERATOR;

constant	: NUMBER | IDENT;

function	: IDENT | OPERATOR;

IDENT 		: ('a'..'z'|'A'..'Z')('a'..'z'|'A'..'Z'|'0'..'9' | '_')* ; 		
NUMBER 		: '0'..'9'+ ;
OPERATOR	: ( '!' | '@' | '#' | '%' | '*' | '-' | '+' | '=' | '\\' | ':' | ';' | '<' | '>' | '.' | '?' | '/' )+ ;

// The following symbols are not operator symbols:
// ~ ^ & and | are mapped onto unicode characters before parsing. NOTE: although - and > can be used, the sequence -> will be mapped on a unicode arrow charactert
// [ ] ( ) , $ _ are already used.
// { } ` ' " don't make much sense as operator symbols

WS  		: (' '|'\t')+ {skip();} ;
